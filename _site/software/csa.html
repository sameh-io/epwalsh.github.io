<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>CSA | Evan Pete Walsh</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="CSA" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A header-only C++ library for Coupled Simulated Annealing" />
<meta property="og:description" content="A header-only C++ library for Coupled Simulated Annealing" />
<link rel="canonical" href="http://0.0.0.0:4000/software/csa.html" />
<meta property="og:url" content="http://0.0.0.0:4000/software/csa.html" />
<meta property="og:site_name" content="Evan Pete Walsh" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://0.0.0.0:4000/software/csa.html","headline":"CSA","description":"A header-only C++ library for Coupled Simulated Annealing","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <link rel="icon" type="image/x-icon" href="https://assets-cdn.github.com/favicon.ico">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CSA</h1>
      <h2 class="project-tagline">A header-only C++ library for Coupled Simulated Annealing</h2>
      <a href="https://github.com/epwalsh/CSA" class="btn">Source</a>
      <a href="https://epwalsh.github.io/CSA/api/" class="btn">Documentation</a>
      <a href="https://epwalsh.github.io" class="btn">Home</a>
    </section>

    <section class="main-content">
      <p><strong>CSA</strong> is a C++ header-only library for
<a href="ftp://ftp.esat.kuleuven.be/sista/sdesouza/papers/CSA2009accepted.pdf">Coupled Simulated Annealing</a>,
a class of optimization methods that doesn’t depend on computing the gradient.
The source code is based on the original implementation by the authors of the paper.</p>

<p>The only requirement for <strong>CSA</strong> is a compiler with OpenMP support.</p>

<h2 id="features">Features</h2>
<ul>
  <li><strong>Global optimization of arbitrary functions:</strong> CSA represents a class of global optimization algorithms that do not make use of the derivative.</li>
  <li><strong>Highly parallel:</strong> The source code is implemented with OpenMP.</li>
  <li><strong>Callback interface:</strong> The optimization method recieves the current cost and next step via a callback interface. Progress updates can also be given through a callback interface.</li>
</ul>

<h2 id="quick-example">Quick example</h2>

<p>In this example we will try to minimize the
<a href="https://www.sfu.ca/~ssurjano/schwef.html">Schwefel function</a>.
We start by defining the function itself:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cmath&gt;
</span>
<span class="cp">#define DIM 10
</span>

<span class="c1">// Schwefel function
</span><span class="kt">double</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">instance</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])));</span>
    <span class="k">return</span> <span class="mf">418.9829</span> <span class="o">*</span> <span class="n">DIM</span> <span class="o">-</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The next thing we need is the random step function:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define PI 3.14159265358979323846264338327
</span>

<span class="c1">// This function will take a random step from `x` to `y`. The value `tgen`,
// the "generation temperature", determines the variance of the distribution of
// the step. `tgen` will decrease according to fixed a schedule throughout the
// annealing process, which corresponds to a decrease in the variance of steps.
</span><span class="kt">void</span> <span class="nf">step</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">instance</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tgen</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fmod</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">tgen</span> <span class="o">*</span> <span class="n">std</span><span class="o">::</span><span class="n">tan</span><span class="p">(</span><span class="n">PI</span> <span class="o">*</span> <span class="p">(</span><span class="n">drand48</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)),</span> <span class="mf">1.</span><span class="p">);</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Optionally, we can define a progress function, which will print updates
to the terminal every time a new minimum cost is found:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This will receive progress updates from the CSA process and print updates
// to the terminal.
</span><span class="kt">void</span> <span class="nf">progress</span><span class="p">(</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">instance</span><span class="p">,</span> <span class="kt">double</span> <span class="n">cost</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tgen</span><span class="p">,</span> <span class="kt">float</span> <span class="n">tacc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opt_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span>
        <span class="s">"bestcost=%1.3e </span><span class="se">\t</span><span class="s"> tgen=%1.3e </span><span class="se">\t</span><span class="s"> tac=%1.3e </span><span class="se">\t</span><span class="s"> thread=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">cost</span><span class="p">,</span>
        <span class="n">tgen</span><span class="p">,</span>
        <span class="n">tacc</span><span class="p">,</span>
        <span class="n">opt_id</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The minimization process is then ran like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;csa.hpp&gt;
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">srand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Create initial solution.
</span>    <span class="kt">double</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">drand48</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Initial cost: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">;,</span> <span class="n">cost</span><span class="p">);</span>

    <span class="c1">// Initialize CSA solver.
</span>    <span class="n">CSA</span><span class="o">::</span><span class="n">Solver</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span> <span class="n">solver</span><span class="p">;</span>
    <span class="n">solver</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// number of threads = number of solvers = 2
</span>
    <span class="c1">// Start the annealing process.
</span>    <span class="n">solver</span><span class="p">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">DIM</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">progress</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>

    <span class="n">cost</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Best cost: %f</span><span class="se">\n</span><span class="s">x =</span><span class="se">\n</span><span class="s">"</span><span class="p">;,</span> <span class="n">cost</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Clean up.
</span>    <span class="k">delete</span><span class="p">[]</span> <span class="n">x</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The last few lines of output should look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
bestcost=1.338e-04       tgen=1.161e-05          tacc=7.006e-44        thread=1
bestcost=1.332e-04       tgen=9.740e-06          tacc=7.006e-44        thread=1
bestcost=1.314e-04       tgen=9.240e-06          tacc=7.006e-44        thread=1
bestcost=1.285e-04       tgen=5.911e-06          tacc=7.006e-44        thread=1
bestcost=1.283e-04       tgen=3.647e-06          tacc=7.006e-44        thread=1
bestcost=1.280e-04       tgen=3.523e-06          tacc=7.006e-44        thread=1
bestcost=1.279e-04       tgen=3.337e-06          tacc=7.006e-44        thread=1
bestcost=1.277e-04       tgen=2.924e-06          tacc=7.006e-44        thread=1
bestcost=1.276e-04       tgen=2.187e-06          tacc=7.006e-44        thread=1
bestcost=1.275e-04       tgen=2.129e-06          tacc=7.006e-44        thread=1
bestcost=1.275e-04       tgen=1.880e-06          tacc=7.006e-44        thread=1
bestcost=1.275e-04       tgen=1.507e-06          tacc=7.006e-44        thread=1
bestcost=1.275e-04       tgen=1.470e-06          tacc=7.006e-44        thread=1
Best cost: 0.000128
x =
420.969 420.969 420.968 420.969 420.968 420.969 420.968 420.969 420.969 420.969
</code></pre></div></div>

<p>This is pretty good, since the true minimum is <code class="highlighter-rouge">0 = f(420.9687, ..., 420.9687)</code>.
Check out <a href="https://github.com/epwalsh/CSA/blob/master/example.cpp">example.cpp</a>”
for the full source code to this example.</p>

<h2 id="documentation">Documentation</h2>

<p>The full API documentation can be found here: <a href="https://epwalsh.github.io/CSA/api/">epwalsh.github.io/CSA/api/</a>.</p>

<h2 id="license">License</h2>

<p>The source code for <strong>CSA</strong> is under the MIT License.</p>


      <footer class="site-footer">
        <span class="site-footer-owner">© 2018 <a href="https://epwalsh.github.io"> Evan Pete Walsh</a>.</span>
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
